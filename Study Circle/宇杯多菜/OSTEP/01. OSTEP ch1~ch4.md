# 【宇多杯菜喇賽會 2 ：OSTEP ch1~ch4】

> 喇賽日期：11/20 週日
> 喇賽人員：杯、多、宇、菜
> 喇賽時間：20:00 ~ 21:00
> 主持喇賽人：多多
>
> 喇賽內容：
> I. [OSTEP](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese)
>
> - ch1 對話：本書 (A Dialogue on the Book)
> - ch2 操作系统介绍 (Introduction to Operating Systems)
> - ch3 對話：虛擬化 (A Dialogue on Virtualization)
> - ch4 抽象：處理程序 (The Abstraction: The Process)
>
> II. [作業](https://github.com/remzi-arpacidusseau/ostep-homework/)
> III. 下次準備：
>
> - [決定] 主持人、內容範圍
> - [投票] 日期、時間
>
> IV. 其他資源
>
> - 這本書會需要用到的 code: [ostep-code
>   ](https://github.com/remzi-arpacidusseau/ostep-code)
> - [common.h](https://github.com/zryfish/ostep/blob/master/common.h)

## # 名詞對照

| 原文           | 台       | 中     |
| -------------- | -------- | ------ |
| concurrency    | 並行性   | 并发   |
| process        | 處理程序 | 进程   |
| program        | 電腦程式 | 程序   |
| memory         | 記憶體   | 内存   |
| disks          | 硬碟     | 磁盘   |
| multi-threaded | 多執行緒 | 多线程 |
| hardware       | 硬體     | 硬件   |
| primitives     | 基本操作 | 原语   |
| Register       | 暫存器   | 寄存器 |

## ch0

- 目的：

  - 釐清操作系統的 **發展脈絡**，有助於更清楚地理解「過去是什麼」、「現在是什麼」、「將來會是什麼」

- 書本三大重點：

  - 虛擬化(virtualization)
  - 並發(concurrency)
  - 持久性(persistence)

- 書本使用方式：
  - `補充`：討論與主要文本相關的內容(可能不必要)
  - `提示`：一般經驗，可應用於所構建的系統
  - `對話`：介紹主要的主題概念，並不時地複習
  - `real code`：書中幾乎是`real code`(在真實系統上運行，是了解`OS`的最佳方式)
  - `crux`：以 灰色框 標註 關鍵問題
  - `附錄專案`：<mark>等待補充 附錄專案是怎樣？去哪裡測試真實代碼？ＹＡ～</mark>

---

## ch1 A Dialogue on the Book

- 通過學習`虛擬化(virtualization)`、`並發(concurrency)`和`持久性(persistence)`理解操作系統：
  - 如何決定接下來哪個 `program` 使用 `CPU`
  - 如何在` virtual memory system`中，處理`memory`使用過載
  - `virtual machine monitors`如何工作
  - 如何管理`disks`上的數據
  - 如何構建 在部分節點失敗時仍能正常工作 的`分佈式系統`

## ch2 Introduction to Operating Systems

### 2.0

> - 關鍵問題:如何將資源虛擬化

    - 通過哪些機制和策略來實現虛擬化?
    - 如何有效地實現虛擬化?
    - 需要哪些硬件支持?

- `操作系統` / `虛擬機(virtual machine)` / `資源管理器(resource manager)`

- `API` / `system call` / `standard library`

- `虛擬化` 讓許多 `program`
  - 同時運行 -> 共享 `CPU`
  - 同時訪問自己的指令和數據 -> 共享 `memory`
  - 同時訪問設備 -> 共享 `disks`

### 2.1 Virtualizing The CPU

- OS 負責提供這種假象(illusion)，即系統擁有非常多的虛擬 CPU 的假象。將單個 CPU(或其中一小部分)轉換為看似無限數量的 CPU， 從而讓許多 `program` 看似同時運行，這就是所謂的 `virtualizing the CPU`
- spin 好像有點像 sleep
- Q: 為何`concurrency`時，無法`ctr+c`關掉？
  - 要用 `fg` 來指到第一個 `progress`，而`ctr+c`只能關掉所指的那一個。

### 2.2 Virtualizing Memory

- 每個`process`訪問自己的`virtual address space`（或稱`address space`），`OS`以某種方式映射到機器的`physical memory`。一個正在運行的`program`中引用`memory`，不會影響其他`process`（或`OS`本身）的地址空間。對於正在運行的`program`，它完全擁有自己的`physical memory`。但實際是，`physical memory`是由`OS`管理的共享資源。

- <mark>Q: 為什麼我在 cs50 sandbox 上測試，每個 `program` 是分配到不同地址？</mark>

  - 因為 cs50 sandbox 沒使用 `virtual address space`？
    - 我在想他後面是不是你每起一個 terminal 他就開一個 docker 給你？
    - 不是。因為宇用電腦環境跑，也是同樣結果。
  - 是不是因為安全性問題，若每次初始化都從 0 開始，容易被推測出哪個地址會放什麼資料？
  - 使用 `virtual address space` 都一定是從第一個位址開始分配？

  ```shell
  ## "./mem & ./mem & ./mem &" 跑三次的結果：

  ## 1st
  (2457) memory address of p: 016fa260
  (2458) memory address of p: 01806260
  (2456) memory address of p: 021cd260

  ## 2nd
  (2519) memory address of p: 0084f260
  (2520) memory address of p: 025ce260
  (2518) memory address of p: 01fb2260

  ## 3td
  (2553) memory address of p: 01fca260
  (2555) memory address of p: 01cb2260
  (2554) memory address of p: 023eb260
  ```

### 2.3 Concurrency

> - 關鍵問題: 如何構建正確的`concurrency program`

    - 同`memory`空間中有並行的`thread`，如何構建正確的`program`?
    - `OS`需要什麼`primitives`?
    - `hardware`應該提供哪些機制?
    - 我們如何利用它們來解決`concurrency`問題?

- Q: `primitives` 跟 `system call` 有什麼不同？

  - `primitives` 是最小單位。`system call`算是 Linux 上的實作。

- 因為`concurrency`時，每個`thread`的指令集，並非以原子方式執行(`atomically`)，並非所有的指令一次性執行

  ```c=
  // 原始：會干擾
  Pthread_create(&p1, NULL, worker, NULL);
  Pthread_create(&p2, NULL, worker, NULL);
  Pthread_join(p1, NULL);
  Pthread_join(p2, NULL);

  // 改成這樣才不會干擾
  // 如此應該沒有兩條 thread 同時執行
  Pthread_create(&p1, NULL, worker, NULL);
  Pthread_join(p1, NULL);
  Pthread_create(&p2, NULL, worker, NULL);
  Pthread_join(p2, NULL);
  ```

  - 測試`Pthread`

    - `Pthread_create`後就會開始執行，有`Pthread_join`才會等其執行完才能再進行其他`Pthread_create`

    ```c
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include "common.h"
    #include "common_threads.h"


    volatile int counter = 0;
    int loops;

    void *worker(void *arg) {
        int i;
        int *array = (int *) arg;
        int flag = array[0];
        int time = array[1];
        for (i = 0; i < loops; i++) {
        // Spin(*(int *) arg);
        Spin(time);
        printf("%d %d\n", flag, i);
        counter++;
        }
        printf("%d %f\n", flag, GetTime());
        return NULL;
    }

    int main(int argc, char *argv[]) {
        if (argc != 2) {
        fprintf(stderr, "usage: threads <loops>\n");
        exit(1);
        }
        loops = atoi(argv[1]);
        pthread_t p1, p2, p3;
        printf("Initial value : %d\n", counter);
        int a[2]= {11, 2};
        int b[2]= {22, 1};
        int c[2]= {33, 1};
        Pthread_create(&p1, NULL, worker, &a);
        Pthread_create(&p2, NULL, worker, &b);
        Pthread_join(p1, NULL);
        // Pthread_join(p2, NULL);
        Pthread_create(&p3, NULL, worker, &c);
        Pthread_join(p3, NULL);
        // Pthread_create(&p1, NULL, worker, NULL);
        // Pthread_join(p1, NULL);
        // Pthread_create(&p2, NULL, worker, NULL);
        // Pthread_join(p2, NULL);
        printf("Final value   : %d\n", counter);
        return 0;
    }

    ```

- <mark>Q: 多 thread 是不是不適合用在需要參考同一個變數的情況下？還是只要把它執行內容包起來即可？</mark>

  - 通常會 lock 住變數。

- <mark>Q: 怎麼寫 atomically？大概後面會教</mark>

### 2.4 Persistence

> - 關鍵問題: 如何持久地存儲數據

    - `file system`是`OS`的一部分，負責管理`持久的`數據。
    - `persistence`需要哪些技術才能正確地實現?
    - 需要哪些機制和策略才能`高性能地`實現?
    - 面對`hardware`和`software`故障，可靠性如何實現?

- Hard Disk Drive

  - `Hard Drive`: temporarily (only when device is on)
  - `Hard Disk`: permanently (even when device is off)
  - `Hard Disk Drive`: hard disk + hard drive

- <mark>Q: 沒有`virtualized disk`?</mark>

- `Disk`寫入操作

  - 性能因素：大多`fs`首先會延遲這些`write`，將其批量分組為較大的組。

    - <mark>Q: 合併為一大組，一起寫入的意思？</mark>
      - 對。因為 I/O 太耗時，所以會集合一起一次去寫入
      - 寫入、讀取也會合併成一大組嗎？
      - 寫入不同 file 也會合併成一大組嗎？

  - 穩定因素：大多`fs`都包含複雜的寫入協議 (journaling, copy-on-write..)，仔細排序，以確保在寫入期間發生故障後，系統可恢復到合理的狀態。

### 2.5 設計目標

- `abstraction`：讓系統方便和易於使用
- `performance`：提供虛擬化和其他功能，同時沒有過多的開銷（時間、空間）
- `protection`：使`program`之間不會互相干擾，也不會干擾`OS`。(`isolation`)
- `reliability`：確保不間斷運行
- `energy-efficiency`
- `security`：`protection`的擴展
- `mobility`

### 2.6 簡單歷史

- [“The Evolution of Operating Systems” P. Brinch Hansen In Classic Operating Systems: From Batch Processing to Distributed Systems Springer-Verlag, New York, 2000](http://www.cs.ucf.edu/courses/cop4600/sum2007/files/2001b.pdf)

- 演進：Just Libraries (I) --> Protection (II) --> Multiprogramming (III) --> The Modern Era (IV)

  - I. 人工手動分批使用（batch）
  - II. `system call`的概念誕生
  - III.
    - 進入`minicomputer`時代 --> `OS`快速發展
    - `I/O`遠慢於`CPU` --> 等待`I/O`時讓`CPU`做其他事。（因此`memory`需不互相干擾）
  - IV.
    - 進入`PC`時代 --> `OS`打廢重來
    - <mark>Q: 因為硬體變太多要重新設計`OS`？還是因為`PC`跟`OS`各自同時發展？還是？</mark>
    - `DOS`, `macOS V9` --> `UNIX` --> `Windows`, `Linux`
    - <mark>Q: 以下這段是指智慧型手機還是舊手機？</mark>
      > 即使在今天的手機上運行的操作系統(如 Linux)，也更像小型機在 20 世紀 70 年代運行的，而不像 20 世紀 80 年現 PC 運行的那種 OS。

- UNIX：最初的基礎是統一原則，即構建小而強大的程序，這些程序可以連接在一起形成更大的工作流。

- Linux：重新編寫的 UNIX 版本，其嚴重依賴最初系統背後的原則和思想，但沒有借用原來的`code`，避免了合法性問題。（開啟現代開源軟體運動）
  - 因隨著公司試圖維護其所有權和利潤，UNIX 的傳播速度有所放慢

<mark>Q: 為毛 UNIX 全大寫，而 Linux</mark>

## ch3 A Dialogue on Virtualization

## ch4 The Abstraction: The Process

- Process 就是 running program，也是 OS 為 running program 提供的抽象。

- `Register`位於`記憶體階層`的最頂端，也是 CPU 可以讀寫的最快的`memory`
  ![](https://i.imgur.com/ADCCuaF.png)
- machine state: 像是記憶體(memory)、寄存器(registers) 和 persistent storage device。

  - <mark>Q: 什麼才是所謂的 machine state？紀錄他的 memory 使用狀態..等等？ 紀錄在哪裡？</mark>

- 分離策略與機制: 將系統如何針對問題提供答案（機制）與系統為哪個問題提供答案的手段（策略）分開，就可以輕鬆地改變策略不影響機制。

- <mark>Q: `progress API` 如 create、destroy、wait 等等，並非指他提供一個 API 讓我們寫在 code 裡面說何時要做這些事，而是我們在生出這個 progress 時，他就自動產生這些接口，讓我們可以在 `progress` 外對他進行這些操作？所有的`progress API`都是這個意思嗎？</mark>
- <mark>Q: 一個 program 是會拆成許多個 progress?好像就是一個？</mark>
- <mark>Q: 從下段中，所以在產生 progress 時，他不是在初始化時，就已經預先分配好需要的 memory 嗎？之後再分配的話，為啥會 stack overflow?超過總 memory 容量嗎？</mark>

  > 隨著程序運行，通過 malloc()庫 API 請求更多內存，操作系統可能會參與分配更多內存給進程， 以滿足這些調用。

- <mark>Q: 椰 來不及研究 file descriptor 是啥鬼？</mark>

- Process 有各式各樣的狀態

  - RUNNING: 正使用 CPU 中。
  - READY: 隨時準備可以使用 CPU。
  - BLOCKED: 等待 IO 中。
  - DONE: 完成執行。

- <mark>Q: 誰去說可以換下一個 progress 來？CPU 自己沒事的時候去問 progress 管理者？</mark>
  要開始了嗎？可
- 新增 Process 時，OS 主要會做的事：

  - 將程式及靜態資料從磁碟讀出後載入 memory。
  - 為程式 run-time stack or stack 分配 memory。
  - 為程式的 heap 分配 memory。
    - 當有呼叫 malloc() 時，會分配更多 memory 。
  - 其他初始化任務，如 file descriptor ，方便 process 讀 terminal 的輸入及輸出。
  - 啟動 main 。

- OS 也是一隻程式，有一些關鍵的資料結構追蹤相關訊息。

- OS 必須追蹤每個 process 為了像是當有 process 停止時，將這個 process 的寄存器保存至內存位置，方便之後恢復 process 。這又稱作 context switch 。

### Homework

根據不同 Run `process-run.py` 想模擬的情境，試著預測 process 運作方式跟 CPU 使用率

1. `./process-run.py -l 5:100,5:100`

   - CPU 使用率是 100%，因為依序執行兩個沒有發生 BLOCKING 的 process。

2. `./process-run.py -l 4:100,1:0`

   - ~~100%? 因為另一個 process 不會用到 CPU~~
   -

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1        RUN:cpu         READY             1
             2        RUN:cpu         READY             1
             3        RUN:cpu         READY             1
             4        RUN:cpu         READY             1
             5           DONE        RUN:io             1
             6           DONE       BLOCKED                           1
             7           DONE       BLOCKED                           1
             8           DONE       BLOCKED                           1
             9           DONE       BLOCKED                           1
            10           DONE       BLOCKED                           1
            11*          DONE   RUN:io_done             1

           Stats: Total Time 11
           Stats: CPU Busy 6 (54.55%)
           Stats: IO Busy  5 (45.45%)
   ```

3. `./process-run.py -l 1:0,4:100`

   - ~~100% 因為在 CPU 等待的時候，去做第二個 process 的事情~~
   -

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1         RUN:io         READY             1
             2        BLOCKED       RUN:cpu             1             1
             3        BLOCKED       RUN:cpu             1             1
             4        BLOCKED       RUN:cpu             1             1
             5        BLOCKED       RUN:cpu             1             1
             6        BLOCKED          DONE                           1
             7*   RUN:io_done          DONE             1

           Stats: Total Time 7
           Stats: CPU Busy 6 (85.71%)
           Stats: IO Busy  5 (71.43%)
   ```

4. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END `

   - 54.55%，可能跟 `./process-run.py -l 4:100,1:0` 一樣，但不知道無法切換但 CPU 有不做事怎麼算？
     - 就沒有算運作，但就無法併發。

5. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO`
   - CPU 使用率應該會更高。
   - 時間縮短
6. `./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_ LATER -c -p`
   - 感覺這種有機會遇到 dead lock

---

## C 補充：

- [common.h](https://github.com/zryfish/ostep/blob/master/common.h)

- [assert](<https://zh.wikipedia.org/zh-tw/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)>)

```c=
// 判斷 x>1 是否為真，false 則結束執行
assert(x > 1);
```

- [S_IRWXU](https://stackoverflow.com/questions/13575543/why-arent-s-irwxg-and-s-irwxo-defined-in-sys-types-h-on-windows)
  - Linux 專用，Windows 不需要

---

## 參考書籍：

- [“Computer Architecture a Quantitative Approach”(1st ed.) David A. Patterson and John L. Hennessy Morgan-Kaufman, 1990](<http://acs.pub.ro/~cpop/SMPA/Computer%20Architecture%20A%20Quantitative%20Approach%20(5th%20edition).pdf>)

  - [浙江大学课程攻略共享计划](https://qsctech.github.io/zju-icicles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/)

  - [计算机体系结构：量化研究方法（第五版）（中文版）.pdf](https://github.com/QSCTech/zju-icicles/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%95%99%E6%9D%90/%E7%AC%AC5%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89.pdf)

- [“Computer Systems: A Programmer’s Perspective”Randal E. Bryant and David R. O’Hallaron Addison-Wesley, 2010](http://csapp.cs.cmu.edu/3e/pieces/preface3e.pdf)

- [“Introduction to Computing Systems: From Bits and Gates to C and Beyond” Yale N. Patt and Sanjay J. Patel McGraw-Hill, 2003](https://www.academia.edu/34254842/INTRODUCTION_TO_COMPUTING_SYSTEMS_FROM_BITS_AND_GATES_TO_C_AND_BEYOND_SECOND_EDITION_International_Edition_2005)

  - [Introduction to Computing Systems 中文](http://staff.ustc.edu.cn/~llxx/cod/reference_books/Introduction%20to%20Computing%20Systems.pdf)

## 下次準備：

### [決定] 主持人、內容範圍

主持人：毛
這次只完成 ch 1~3 討論
下次：ch 4~6 ＋ 作業

### [投票] 日期、時間
