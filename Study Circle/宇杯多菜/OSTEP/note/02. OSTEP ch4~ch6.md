# 【宇多杯菜會喇賽 3 ：OSTEP ch4~ch6】

> 喇賽日期：投票中
> 喇賽人員：杯、多、宇、菜
> 喇賽時間：20:00 ~ 21:00
> 主持喇賽人：多多
>
> 喇賽內容：
> I. [OSTEP](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese)
>
> - ch4 抽象：處理程序 (The Abstraction: The Process)
> - ch5 插曲：處理程序 API（Interlude: Process API）
> - ch6 機制:受限直接執行（Mechanism: Limited Direct Execution）
>
> II. [作業](https://github.com/remzi-arpacidusseau/ostep-homework/)
>
> IV. 其他資源
>
> - 這本書會需要用到的 code: [ostep-code
>   ](https://github.com/remzi-arpacidusseau/ostep-code)

## # 名詞對照

| 原文           | 台       | 中     |
| -------------- | -------- | ------ |
| concurrency    | 並行性   | 并发   |
| process        | 處理程序 | 进程   |
| program        | 電腦程式 | 程序   |
| memory         | 記憶體   | 内存   |
| disks          | 硬碟     | 磁盘   |
| multi-threaded | 多執行緒 | 多线程 |
| hardware       | 硬體     | 硬件   |
| primitives     | 基本操作 | 原语   |
| Register       | 暫存器   | 寄存器 |

---

## ch4 The Abstraction: The Process

- Process 就是 running program，也是 OS 為 running program 提供的抽象。

- `Register`位於`記憶體階層`的最頂端，也是 CPU 可以讀寫的最快的`memory`
  ![](https://i.imgur.com/ADCCuaF.png)
- machine state: 像是記憶體(memory)、寄存器(registers) 和 persistent storage device。

  - <mark>Q: 什麼才是所謂的 machine state？紀錄他的 memory 使用狀態..等等？ 紀錄在哪裡？</mark>

- 分離策略與機制: 將系統如何針對問題提供答案（機制）與系統為哪個問題提供答案的手段（策略）分開，就可以輕鬆地改變策略不影響機制。

- <mark>Q: `process API` 如 create、destroy、wait 等等，並非指他提供一個 API 讓我們寫在 code 裡面說何時要做這些事，而是我們在生出這個 process 時，他就自動產生這些接口，讓我們可以在 `process` 外對他進行這些操作？所有的`process API`都是這個意思嗎？</mark>
- <mark>Q: 一個 program 是會拆成許多個 process?好像就是一個？</mark>
- <mark>Q: 從下段中，所以在產生 process 時，他不是在初始化時，就已經預先分配好需要的 memory 嗎？之後再分配的話，為啥會 stack overflow?超過總 memory 容量嗎？</mark>

  > 隨著程序運行，通過 malloc()庫 API 請求更多內存，操作系統可能會參與分配更多內存給進程， 以滿足這些調用。

- <mark>Q: 椰 來不及研究 file descriptor 是啥鬼？</mark>

- Process 有各式各樣的狀態

  - RUNNING: 正使用 CPU 中。
  - READY: 隨時準備可以使用 CPU。
  - BLOCKED: 等待 IO 中。
  - DONE: 完成執行。

- <mark>Q: 誰去說可以換下一個 process 來？CPU 自己沒事的時候去問 process 管理者？</mark>
  要開始了嗎？可
- 新增 Process 時，OS 主要會做的事：

  - 將程式及靜態資料從磁碟讀出後載入 memory。
  - 為程式 run-time stack or stack 分配 memory。
  - 為程式的 heap 分配 memory。
    - 當有呼叫 malloc() 時，會分配更多 memory 。
  - 其他初始化任務，如 file descriptor ，方便 process 讀 terminal 的輸入及輸出。
  - 啟動 main 。

- OS 也是一隻程式，有一些關鍵的資料結構追蹤相關訊息。

- OS 必須追蹤每個 process 為了像是當有 process 停止時，將這個 process 的寄存器保存至內存位置，方便之後恢復 process 。這又稱作 context switch 。

### Homework

根據不同 Run `process-run.py` 想模擬的情境，試著預測 process 運作方式跟 CPU 使用率

1. `./process-run.py -l 5:100,5:100`

   - CPU 使用率是 100%，因為依序執行兩個沒有發生 BLOCKING 的 process。

2. `./process-run.py -l 4:100,1:0`

   - ~~100%? 因為另一個 process 不會用到 CPU~~
   -

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1        RUN:cpu         READY             1
             2        RUN:cpu         READY             1
             3        RUN:cpu         READY             1
             4        RUN:cpu         READY             1
             5           DONE        RUN:io             1
             6           DONE       BLOCKED                           1
             7           DONE       BLOCKED                           1
             8           DONE       BLOCKED                           1
             9           DONE       BLOCKED                           1
            10           DONE       BLOCKED                           1
            11*          DONE   RUN:io_done             1

           Stats: Total Time 11
           Stats: CPU Busy 6 (54.55%)
           Stats: IO Busy  5 (45.45%)
   ```

3. `./process-run.py -l 1:0,4:100`

   - ~~100% 因為在 CPU 等待的時候，去做第二個 process 的事情~~
   -

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1         RUN:io         READY             1
             2        BLOCKED       RUN:cpu             1             1
             3        BLOCKED       RUN:cpu             1             1
             4        BLOCKED       RUN:cpu             1             1
             5        BLOCKED       RUN:cpu             1             1
             6        BLOCKED          DONE                           1
             7*   RUN:io_done          DONE             1

           Stats: Total Time 7
           Stats: CPU Busy 6 (85.71%)
           Stats: IO Busy  5 (71.43%)
   ```

4. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END `

   - 54.55%，可能跟 `./process-run.py -l 4:100,1:0` 一樣，但不知道無法切換但 CPU 有不做事怎麼算？
     - 就沒有算運作，但就無法併發。

5. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO`
   - CPU 使用率應該會更高。
   - 時間縮短
6. `./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_ LATER -c -p`
   - 感覺這種有機會遇到 dead lock

---

## ch5 Interlude: Process API

---

## ch6 Mechanism: Limited Direct Execution

## 下次準備：

### [決定] 主持人、內容範圍

### [投票] 日期、時間
