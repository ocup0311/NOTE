# 【宇多杯菜會喇賽 3 ：OSTEP ch4~ch6】

> 喇賽日期：12/4
> 喇賽人員：杯、多
> 喇賽時間：20:00 ~ 21:00
> 主持喇賽人：多多
>
> 喇賽內容：
> I. [OSTEP](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese)
>
> - ch4 抽象：處理程序 (The Abstraction: The Process)
> - ch5 插曲：處理程序 API（Interlude: Process API）
> - ch6 機制:受限直接執行（Mechanism: Limited Direct Execution）
>
> II. [作業](https://github.com/remzi-arpacidusseau/ostep-homework/) | [解答](https://github.com/jzplp/OSTEP-Answers)
>
> IV. 其他資源
>
> - [原文書](https://pages.cs.wisc.edu/~remzi/OSTEP/)
> - 書本 code: [ostep-code](https://github.com/remzi-arpacidusseau/ostep-code)
> - [名詞對照表](https://hackmd.io/@e_Me9JgsS1y8VahM1nF7wg/Skk8y3u8j)

---

## ch4 The Abstraction: The Process

- <mark>TODO:待確認</mark>`$ ls -la /dev`：可查看所有的 process

### 4.0

- 想更好地實作 CPU Virtualization，需要低階的`mechanism`與高階的`policy`

### 4.1 The Abstraction: A Process

- 在任何時刻，我們都可以清點它在執行過程中 訪問或影響的系統的不同部分，從而概括一個 Process。

- 為了理解 Process 的構成，必須先理解它的 machine state

  - <mark>TODO:Q</mark> machine state 紀錄在哪裡？

- `分離 mechanism 與 policy`：將 mechanism 與 policy 分開，就可以輕鬆地改變 policy 不影響 mechanism。

### 4.2 Process API

- 現代 OS 都以某種形式提供 create、destroy、wait、miscellaneous control、statu 等等 API

<!-- Q & A -->

- <details close>
  <summary>Q & A</summary>

  - Q: 一個 program 是會拆成許多個 process?還是就只一個？
    - 最初始就是一個 process，但在 program 中可能包含一些如 fork 的指令，再分化出更多 process

  </details>

### 4.3 Process Creation: A Little More Detail

- <mark>Q: 從下段中，所以在產生 process 時，他不是在初始化時，就已經預先分配好需要的 memory 嗎？之後再分配的話，為啥會 stack overflow?超過總 memory 容量嗎？</mark>

  > 隨著程序運行，通過 malloc()庫 API 請求更多內存，操作系統可能會參與分配更多內存給進程， 以滿足這些調用。

- <mark>Q: file descriptor 是啥鬼？</mark>

<!-- Q & A -->

- <details close>
  <summary>Q & A</summary>

  </details>

### 4.4 Process States

- Process 有各式各樣的狀態

  - RUNNING: 正使用 CPU 中。
  - READY: 隨時準備可以使用 CPU。
  - BLOCKED: 等待 IO 中。
  - DONE: 完成執行。

- <mark>Q: 誰去說可以換下一個 process 來？CPU 自己沒事的時候去問 process 管理者？</mark>

- 新增 Process 時，OS 主要會做的事：

  - 將程式及靜態資料從磁碟讀出後載入 memory。
  - 為程式 run-time stack or stack 分配 memory。
  - 為程式的 heap 分配 memory。
    - 當有呼叫 malloc() 時，會分配更多 memory 。
  - 其他初始化任務，如 file descriptor ，方便 process 讀 terminal 的輸入及輸出。
  - 啟動 main 。

### 4.5 Data Structures

- OS 也是一隻程式，有一些關鍵的資料結構追蹤相關訊息。

- OS 必須追蹤每個 process 為了像是當有 process 停止時，將這個 process 的寄存器保存至內存位置，方便之後恢復 process 。這又稱作 context switch 。

### # Homework

- 歸納：

  - 初始設定下，當沒有 `i/o` 時，就會一直同一個 `process` 在使用 `CPU`
  - 預設每次 `i/o` 需要 5 time
  - `io_done` 也需要 1 time
  - 初始設定下，會按照指令順序執行
  - `SWITCH_ON_END`: `process` 完全執行完才換下一個

- Q:
  - 為啥`RUN:io_done`要加 `*` 號

根據不同 Run `process-run.py` 想模擬的情境，試著預測 process 運作方式跟 CPU 使用率

1. `./process-run.py -l 5:100,5:100`

   - CPU 使用率是 100%，因為依序執行兩個沒有發生 BLOCKING 的 process。

2. `./process-run.py -l 4:100,1:0`

   - ~~100%? 因為另一個 process 不會用到 CPU~~
   - 6 /11 = 54.55%

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1        RUN:cpu         READY             1
             2        RUN:cpu         READY             1
             3        RUN:cpu         READY             1
             4        RUN:cpu         READY             1
             5           DONE        RUN:io             1
             6           DONE       BLOCKED                           1
             7           DONE       BLOCKED                           1
             8           DONE       BLOCKED                           1
             9           DONE       BLOCKED                           1
            10           DONE       BLOCKED                           1
            11*          DONE   RUN:io_done             1

           Stats: Total Time 11
           Stats: CPU Busy 6 (54.55%)
           Stats: IO Busy  5 (45.45%)
   ```

3. `./process-run.py -l 1:0,4:100`

   - ~~100% 因為在 CPU 等待的時候，去做第二個 process 的事情~~
   - 6 / 7 = 85.71%

   ```bash
           Time        PID: 0        PID: 1           CPU           IOs
             1         RUN:io         READY             1
             2        BLOCKED       RUN:cpu             1             1
             3        BLOCKED       RUN:cpu             1             1
             4        BLOCKED       RUN:cpu             1             1
             5        BLOCKED       RUN:cpu             1             1
             6        BLOCKED          DONE                           1
             7*   RUN:io_done          DONE             1

           Stats: Total Time 7
           Stats: CPU Busy 6 (85.71%)
           Stats: IO Busy  5 (71.43%)
   ```

4. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END `

   - 54.55%，可能跟 `./process-run.py -l 4:100,1:0` 一樣，但不知道無法切換但 CPU 有不做事怎麼算？
     - 就沒有算運作，但就無法併發。

5. `./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO`

   - CPU 使用率應該會更高。
   - 時間縮短
   - 6 / 7 = 85.71%
   - 看來預設就是有加 `SWITCH_ON_IO`

6. `./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p`

   - 感覺這種有機會遇到 dead lock
   - 預設也是 `IO_RUN_LATER`

7. `./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p`

   - 為什麼運行一個剛剛完成 I/O 的進程會是一個好主意?

   > 網友說：因為有過 IO 操作的進程很有可能後面也會進行 IO 操作，為了使 CPU 有效利用，應該在 IO 結束不久後運行該進程，使其得到繼續阻塞 IO 的機會。
   > 我說：為啥有過 IO 操作的進程很有可能後面也會進行 IO 操作？

8. `./process-run.py -s 1 -l 3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50`

---

## ch5 Interlude: Process API

### Process API

**fork()**

Parent 在 fork() 的返回值是新創建的 child 的 pid ，而 child 在 fork() 後的返回值是 0 。fork 後，對於 OS 來說，有兩個幾乎一模一樣的 process 在執行。

Child 不會從 main 開始執行，而是從 fork() 後開始，就像自己呼叫過 fork() 一樣。

根據不同的 scheduler ， 在 parent 跟 child 的處理有不同的先後順序。

**wait()**

利用 wait() 可以強制讓 Parent ~~或是 child ~~強制等 child 結束再執行。BUT 也要注意不是絕對。（開發時請參閱~~公開說明書~~man）

**exec()**

執行中的 process 藉由 load code 和資料來覆寫自己。

- Q: strdup() 不能用相對路徑 (p3.c)
  - 原來相對路徑跟編譯後的 file、.c file 都無關，是跟 terminal 所在位置有關
- Q: p4
  - 1.  不要 redirect -> 通通印出來
  - 2.  redirect -> 只印出 exec 結果
  - 3.  redirect + 多條 printf -> 全部印出來

### # Homework

1.  - `fork()`擁有自己的空間，不跟 parent 重疊
2.  - process 是紀錄什麼？
    - 重新 open 再 write 會覆蓋整個 file，close 後就無法 write
    - 但每個 fork 中 close 後，不影響其他 process 的 write

3.  - 可以，偷用 `sleep()`，但不是真的。
    - 是否有其他方法？正規感覺就是用 `wait()`
    - 網友：使用`vfork()`，child 結束後才會執行 parent。
      - warning: 'vfork' is deprecated: Use posix_spawn or fork [-Wdeprecated-declarations]

4.  -

5.  - `wait()`返回等待的 pid。(child pid)
    - 若沒有 child 則返回 -1

6.  - `waitpid()`用在已知 child pid
    - [REF](https://wirelessr.gitbooks.io/working-life/content/wait_vs_waitpid.html) 但我覺得現在好像不會出現她描述的問題? 因為就算我在 child 那邊 wait 也不會卡住，他會回傳 -1

**1. Main process 中如果有變數，fork 後 parent 和 child 去改變他會有什麼情況？**

fork 後，無論 parent 或 child 誰 wait 誰，誰去改那個變數都不會影響到對方。

**2. 打開文件後再 fork 會對 parent 和 child 有什麼影響？**

Parent 和 child 都可以訪問文件，也都可以寫入。

**3. 承上題，如果想要 child 印 hello，parent 印 goodbye ，有辦法不靠 wait 做到這點嗎？**

沒有想法。

**4. exec() 系列函數的意義？**

有用到再看好 🤪。

- [Linux 系統編程之進程（五）：exec 系列函數（execl,execlp,execle,execv,execvp)使用](https://jasonblog.github.io/note/linux_system/linuxxi_tong_bian_cheng_zhi_jin_cheng_ff08_wu_ff09.html)
- [execlp、execvp 用法與範例])(https://burweisnote.blogspot.com/2017/08/execlpexecvp.html)

**5. fork() 後，wait() 會返回什麼？如果 child 用的話會怎樣？**

在 parent 用 wait() 會得到 child 的 process id；在 child 用 wait 會得到 -1。；兩個同時用 child 的 wait 會得到 -1，而 parent 會得到 child 的 process id。

**6. waitpid()**

waitpid() 需要給定 pid 及回傳狀態，讓 parent 知道要等到什麼時候。

- [wait vs. waitpid](https://wirelessr.gitbooks.io/working-life/content/wait_vs_waitpid.html)
- [linux 中 waitpid 及 wait 的用法](https://www.twblogs.net/a/5b83317c2b717766a1eb53be)

**7. 如果在 child 關閉 STDOUT_FILENO 後，printf 會出現什麼？**
