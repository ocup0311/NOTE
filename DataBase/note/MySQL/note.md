##### <!-- 收起 -->

<!----------- ref start ----------->

[ON UPDATE/DELETE 作用]: https://blog.csdn.net/u013636377/article/details/51313669
[MariaDB Error Codes]: https://mariadb.com/kb/en/mariadb-error-codes/
[Prisma Doc: Data Proxy]: https://www.prisma.io/docs/data-platform/data-proxy
[MySQL Doc: SHOW Statements]: https://dev.mysql.com/doc/refman/8.0/en/show.html
[validate_password]: https://dev.mysql.com/doc/refman/8.0/en/validate-password.html
[MySQL shell]: https://github.com/dbcli/mycli
[MySQL Doc: BINARY]: https://dev.mysql.com/doc/refman/8.0/en/cast-functions.html#operator_binary
[MySQL 函數 ｜鐵人]: https://ithelp.ithome.com.tw/articles/10034496
[MySQL Doc: Operator]: https://dev.mysql.com/doc/refman/8.0/en/non-typed-operators.html
[MySQL Doc: Date and Time Functions]: https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
[MySQL Doc: Date]: https://dev.mysql.com/doc/refman/8.0/en/datetime.html
[DataType (from ntct)]: http://ftp.ntct.edu.tw/%E7%A0%94%E7%BF%92%E6%95%99%E6%9D%90/95%E5%B9%B4%E6%9A%91%E6%9C%9F%E7%A0%94%E7%BF%92/php&mysql+xoops/0710%E4%B8%8A%E8%AA%B2/%E6%AC%84%E4%BD%8D%E5%9E%8B%E6%85%8B.htm
[MySQL Doc: Server SQL Modes]: https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html
[MySQL Doc: Precision Math]: https://dev.mysql.com/doc/refman/8.0/en/precision-math.html
[MySQL Doc: DataType]: https://dev.mysql.com/doc/refman/8.0/en/data-types.html
[MySQL issue answer]: https://bugs.mysql.com/bug.php?id=79808
[MySQL EXPLAIN Extra 解析]: https://www.modb.pro/db/409873
[MySQL doc: COUNT()]: https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_count
[MySQL 中 IS NULL、IS NOT NULL、!= 不能用索引？]: https://juejin.cn/post/6844903921450745863
[分析 COUNT(*)]: https://mp.weixin.qq.com/s/eh7G_J3a0JudZRR-wrElag
[Optimizing SELECT Statements]: https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html
[Aggregate Function]: https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions-and-modifiers.html
[String Functions]: https://dev.mysql.com/doc/refman/8.0/en/string-functions.html
[MySQL DOC: Character Sets, Collations, Unicode]: https://dev.mysql.com/doc/refman/8.0/en/charset.html
[What is the sorting algorithm behind ORDER BY query in MySQL?]: https://www.pankajtanwar.in/blog/what-is-the-sorting-algorithm-behind-order-by-query-in-mysql
[MySQL：排序（filesort）詳細解析]: https://zhuanlan.zhihu.com/p/101921329
[MySQL DOC: SELECT Statement]: https://dev.mysql.com/doc/refman/8.0/en/select.html
[MySQL DOC: ORDER BY Optimization]: https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html
[Optimize Table 整理 MySQL 表空間]: https://www.796t.com/content/1545213008.html
[圖解｜索引覆蓋、索引下推以及如何避免索引失效]: https://zhuanlan.zhihu.com/p/481750465
[資料庫索引深入淺出(二)]: https://isdaniel.github.io/dbindex-2/
[MySQL 覆蓋索引詳解]: https://juejin.cn/post/6844903967365791752
[MySQL 面試：談談你對聚簇索引的理解]: https://blog.csdn.net/zhizhengguan/article/details/120834883?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168785250216800182784361%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168785250216800182784361&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-120834883-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187
[詳解聚簇索引]: https://blog.csdn.net/crazzy_lp/article/details/84650621?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-84650621.142^v88^koosearch_v1,239^v2^insert_chatgpt&spm=1018.2226.3001.4187
[MySQL 底層為什麼要選用 B+樹作為索引的數據結構呢？]: https://blog.csdn.net/cckevincyh/article/details/119003282?spm=1001.2014.3001.5501
[平衡二叉樹、B 樹、B+樹、B*樹理解其中一種你就都明白了]: https://zhuanlan.zhihu.com/p/27700617
[資料庫層的核心 - 索引結構演化論 B+樹]: https://mark-lin.com/posts/20190911/
[聚簇索引]: https://blog.csdn.net/taoqilin/article/details/121230649?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168785250216800182784361%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168785250216800182784361&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121230649-null-null.142^v88^koosearch_v1,239^v2^insert_chatgpt&utm_term=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187
[MySQL 開發規範參考]: https://mp.weixin.qq.com/s?__biz=MzUzNzAzMTc3MA==&mid=2247484130&idx=1&sn=4bae9fdac414a5ee3157b2f9d94f5592&scene=21#wechat_redirect
[Should You Run Your Database in Docker?]: https://vsupalov.com/database-in-docker/

<!------------ ref end ------------>

# MySQL

## # <mark>待整理筆記區</mark>

- `IFNULL()`、`CONVERT()`

---

## # 簡介

- 定義：一般會把 `DBMS + Database` 這兩部分合稱 Database

  - DBMS (Database Management System)

    - RDBMS： MySQL、Oracle、Microsoft SQL Server 等
    - NoSQL DBMS：MongoDB、Cassandra、Redis 等

  - SQL (Structured Query Language)
    - 用於溝通 Relational database 的標準語言

  <br>

  ![](https://i.imgur.com/KydSI1d.png)

## # 安裝

<mark>TODO:</mark> 再修改整理

<!-- - 以`Homebrew`安裝
- 以`docker`啟動
- `mysql_secure_installation`進行安全設置

  - 設定每次連線所需的密碼
  - 設定是否開放遠端連線 --NO-> 只能在本機連線
  - 設定是否開放 test user --NO-> 只能用 root 連線

- `mysql -u root -p`進入 MySQL 介面

  - `-u <user>`：以該 user 身份執行
  - `-p`：輸入密碼

- chatGPT ref
  ![](https://i.imgur.com/1uue1fp.png)
  ![](https://i.imgur.com/58eyRt2.png)
  ![](https://i.imgur.com/vmIzzV0.png) -->

## # 基礎指令

<!-- 速記小抄 (Cheat Sheet) -->

- <details close>
  <summary>速記小抄 (Cheat Sheet)</summary>

  ![](./src/image/SQL_cheat_sheet1.jpeg)
  ![](./src/image/SQL_cheat_sheet2.png)

  </details>

<!-- 基本設定查詢 -->

- <details close>
  <summary>基本設定查詢</summary>

  <!-- SELECT VERSION(); -->

  - <details close>
    <summary><code>SELECT VERSION();</code></summary>

    - 查看 MySQL 版本

    </details>

  <!-- SELECT DATABASE(); -->

  - <details close>
    <summary><code>SELECT DATABASE();</code></summary>

    - 查詢目前正在 use 的 DB

    </details>

  <!-- DELIMITER symbol -->

  - <details close>
    <summary><code>DELIMITER symbol</code></summary>

    - 更改結尾的符號
    - 當前環境生效，若 exit 再回來則回覆成 `;`

    ```sql
    # EX. 原本用 ; 結尾
    > SELECT * FROM users;

    # 改成用 # 結尾
    > DELIMITER #
    > SELECT * FROM users#

    # exit 後恢復 ;
    > exit
    $ mysql -r root -p
    > SELECT * FROM users;
    ```

    </details>

  <!-- DESCRIBE table; -->

  - <details close>
    <summary><code>DESCRIBE table;</code></summary>

    - 秀出該 table 的樣貌

    </details>

  <!-- SHOW WARNINGS; -->

  - <details close>
    <summary><code>SHOW WARNINGS;</code></summary>

    - REF: [MariaDB Error Codes]
    - 列出上一個操作所造成的 Error 或 Warning
    - 只要做新的 SQL 動作，前面的 warning 就消失了

    </details>

  <!-- SHOW VARIABLES; -->

  - <details close>
    <summary><code>SHOW VARIABLES;</code></summary>

    - 列出所有 DB server 中的變數設定
    - 設定方式：`SET var_name="var_value"`

    </details>

  <!-- SHOW CREATE DATABASE db_name; -->

  - <details close>
    <summary><code>SHOW CREATE DATABASE db_name;</code></summary>

    - [MySQL Doc: SHOW Statements]
    - 可以查詢該 database 的資訊 (CHARACTER SET, COLLATE, ENCRYPTION)
    - 同理可查 `SCHEMA`

    </details>

  </details>

<!-- CRUD -->

- <details close>
  <summary>CRUD</summary>

  <!-- INSERT INTO -->

  - <details close>
    <summary><code>INSERT INTO</code></summary>

    - `INSERT INTO table(col1, col2) VALUES(col1, col2);`，是按照順序來進行配對 column

    </details>

  </details>

<!-- Optimizing SELECT Statements -->

- <details close>
  <summary>Optimizing SELECT Statements</summary>

  - [Optimizing SELECT Statements]

  <!-- ORDER BY -->

  - <details close>
    <summary><code>ORDER BY</code></summary>

    - `DESC` 降冪 (預設為升冪)

      - 排序方式從 升冪 改為 降冪
      - EX. `SELECT * FROM employees ORDER BY salary DESC;`

    - `ORDER BY 1`

      - 依照 SELECT 的第一項 (EX. name) 來排序
      - EX. `SELECT name, salary FROM employees ORDER BY 1;`

    </details>

  <!-- LIMIT -->

  - <details close>
    <summary><code>LIMIT</code></summary>

    - 可用 `18446744073709551615` 確保列出 LIMIT 後全部內容
    - EX. `SELECT * FROM tbl LIMIT 95,18446744073709551615;`
    - REF: [MySQL DOC: SELECT Statement]

    </details>

  <!-- LIKE -->

  - <details close>
    <summary><code>LIKE</code></summary>

    <!-- `%` 省略 -->

    - <details close>
      <summary><code>%</code> 省略</summary>

      - EX. `SELECT * FROM table_name LIKE "%A";`
      - EX. `SELECT * FROM table_name LIKE "A%";`
      - EX. `SELECT * FROM table_name LIKE "%A%";`
      </details>

    <!-- `_` 省略數量 -->

    - <details close>
      <summary><code>_</code> 省略數量</summary>

      - 有幾個 `_` 就代表幾個 char
      - EX. `SELECT * FROM table_name LIKE "__A";`
      - EX. `SELECT * FROM table_name LIKE "A___";`
      </details>

    <!-- 預設不會區分大小寫 -->

    - <details close>
      <summary>預設不會區分大小寫</summary>

      - 可用 `BINARY` 區分大小寫
      - EX. `SELECT * FROM table_name WHERE col_name LIKE BINARY 'J%';`

      </details>

    <!-- 效能注意 -->

    - <details close>
      <summary>效能注意</summary>

      - 使用 `%`, `_` 等開頭，會無法使用 index

      </details>

    </details>

  </details>

<!-- Function -->

- <details close>
  <summary>Function</summary>

  <!-- String Function -->

  - <details close>
    <summary>String Function</summary>

    - [String Functions]

    - `CONCAT`、`CONCAT_WS`、`SUBSTR`、`REPLACE`、`REVERSE`、`CHAR_LENGTH`、`LOWER`、`UPPER`、`TRIM`、``

    </details>

  <!-- DateTime Function -->

  - <details close>
    <summary>DateTime Function</summary>

    - `NOW()`、`CURRENT_TIMESTAMP()`、`CURRENT_TIMESTAMP`

      - MySQL 中，都是回傳當下時區的時間
      - 需注意就算以數字格式呈現，也不是 TIMESTAMP，而是 DATETIME

    - `NOW()` vs `SYSDATE()`

      - `NOW()`、`CURRENT_TIMESTAMP()` 是執行準備開始的時間
      - `SYSDATE()` 是真正執行時的時間

      ![NOW_vs_SYSDATE.png](./src/image/NOW_vs_SYSDATE.png)

    - `DATEDIFF()`、`TIMESTAMPDIFF()`

      - `DATEDIFF()` 回傳「天數」
      - `TIMESTAMPDIFF()` 自己指定

    - [MySQL Doc: Date and Time Functions]

    </details>

  <!-- Information Function -->

  - <details close>
    <summary>Information Function</summary>

    - `CONNECTION_ID()`、`DATABASE()`、`LAST_INSERT_ID()`、`USER()`、`VERSION()`

    - `LAST_INSERT_ID()`

      - 同時插入多筆資料，會回傳第一筆的 id

      ```sql
      ## EX. 一次 INSERT a,b,c，但 LAST_INSERT_ID() 會回傳 a 的 id

      mysql> SELECT * FROM table1;
      +----+------+
      | id | col1 |
      +----+------+
      | 1  | x    |
      +----+------+

      mysql> INSERT INTO table1(col1) VALUES('a'),('b'),('c');

      mysql> SELECT * FROM table1;
      +----+------+
      | id | col1 |
      +----+------+
      | 1  | x    |
      | 2  | a    |
      | 3  | b    |
      | 4  | c    |
      +----+------+

      mysql> SELECT LAST_INSERT_ID();
      +------------------+
      | LAST_INSERT_ID() |
      +------------------+
      |                2 |
      +------------------+
      ```

    </details>

  <!-- Aggregate Function -->

  - <details close>
    <summary>Aggregate Function</summary>

    - [Aggregate Function]

    - `COUNT`、`DISTINCT`、`SUM`、`MAX`、`MIN`、`AVG`

    <!-- GROUP BY -->

    - <details close>
      <summary><code>GROUP BY</code></summary>

      - `HAVING`：類似於 `GROUP BY` 的 `WHERE`，但本質上不同

      </details>

    <!-- HAVING VS WHERE -->

    - <details close>
      <summary><code>HAVING</code> VS <code>WHERE</code></summary>

      - `WHERE`：查表時進行篩選
      - `HAVING`：對查詢結果進行篩選

      - 當在一般情形，直接以 `HAVING` 替代 `WHERE`，則會先返回結果才進行篩選，導致其掃表的範圍變大、返回的內容變多

        ![HAVING_vs_WHERE.png](./src/image/HAVING_vs_WHERE.png)

      </details>

    </details>

  <!-- Encryption and Compression Functions -->

  - <details close>
    <summary>Encryption and Compression Function</summary>

    - `MD5()`、`SHA1()`、`SHA2()`

    - `VALIDATE_PASSWORD_STRENGTH()`

      - 需先安裝 [validate_password]
      - 回傳密碼強度
      - 不會記錄在 shell 的 history

    </details>

  </details>

<!-- Operator -->

- <details close>
  <summary>Operator</summary>

  - [MySQL Doc: Operator]

  - `NOT`、`!=`、`LIKE`、`BINARY`、`AND`、`OR`、`BETWEEN`、`IN`、`CASE`

  - `BINARY`

    - 轉成 binary string，可以進行 byte by byte 的比較 (沒轉之前為 char by char，所以才無法區分大小寫)

    - 範例

      - 在查詢時才指定 COLLATE

        - EX. `SELECT * FROM table_name WHERE col_name LIKE BINARY 'J%';`

      - 在定義欄位時，同時定義預設的 COLLATE

        - EX. `CREATE TABLE table_name(col_name VARCHAR(5) BINARY);`

      ```sql
      ## 預設為 utf8mb4 時，以下兩兩同義：
      CHAR(10) BINARY
      CHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin

      CHAR(10) CHARACTER SET binary
      BINARY(10)
      ```

    - REF: [MySQL Doc: BINARY] | [MySQL 函數 ｜鐵人]

  - `BETWEEN`

    - 包含前後兩個
    - EX. `SELECT * FROM table_name WHERE col_name BETWEEN 1 AND 5;` 中，回傳資料包含 1 & 5

  - `CASE`

    ```sql
    ## EX. 依照分數分類為 1 ~ 5 顆星，並在查詢結果增加一個 col 為 stars

    SELECT *,
      CASE
        WHEN score>=8 THEN "*****"
        WHEN score>=7 AND score<8 THEN "****"
        WHEN score>=6 AND score<7 THEN "***"
        WHEN score>=5 AND score<6 THEN "**"
        ELSE "*"
      END AS stars
    FROM movie
    ```

  </details>

<!-- Index -->

- <details close>
  <summary>Index</summary>

  <!-- CREATE INDEX index_name ON table_name(title); -->

  - `CREATE INDEX index_name ON table_name(title);`

  <!-- SHOW INDEXES FROM table_name; -->

  - `SHOW INDEXES FROM table_name;`

  </details>

<!-- ALTER -->

- <details close>
  <summary><code>ALTER</code></summary>

  - `ALTER TABLE table_name MODIFY col_name TYPE_NAME;`

    - 更改 col 的 type
    - 需相容所有已存在的資料，才能改變

  </details>

<!-- JOIN -->

- <details close>
  <summary><code>JOIN</code></summary>

  <!-- 基本 -->

  - <details close>
    <summary>基本</summary>

    - `join buffer` 預設：256KB
    - `SHOW VARIABLES LIKE 'join_%';`

    </details>

  <!-- JOIN 的過程 -->

  - <details close>
    <summary>JOIN 的過程</summary>

    </details>

  <!-- `ON` vs `WHERE` -->

  - <details close>
    <summary><code>ON</code> vs <code>WHERE</code></summary>

    </details>

  <!-- FOREIGN KEY -->

  - <details close>
    <summary><code>FOREIGN KEY</code></summary>

    - EX. `FOREIGN KEY(table_name_id) REFERENCES table_name(id)`

    - 插入時，`table_name_id` 欄位會進行檢查，只能填入已存在的 `table_name.id`
    - 一些規範，不建議使用 `FOREIGN KEY`，因為會降低效能 (可能都會在 server 端進行檢查)

    </details>

  <!-- ON DELETE CASCADE -->

  - <details close>
    <summary><code>ON DELETE CASCADE</code></summary>

    - [ON UPDATE/DELETE 作用]

    </details>

  ![JOIN_3_type.png](./src/image/JOIN_3_type.png)

  </details>

<!-- COLLATE -->

- <details close>
  <summary><code>COLLATE</code></summary>

  </details>

## # Data Type

- REF: [MySQL Doc: DataType] | [DataType (from ntct)]

<!-- Numeric Type -->

- <details close>
  <summary>Numeric Type</summary>

  <!-- Interger Types -->

  - <details close>
    <summary>Interger Types</summary>

    - `TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`
    - 1、2、3、4、8 byte
    - 可以使用 `UNSIGNED`
      - EX. `INT UNSIGNED`

    </details>

  <!-- Fixed-Point Types -->

  - <details close>
    <summary>Fixed-Point Types</summary>

    - `DECIMAL`、`NUMERIC`

    <!-- size (`DECIMAL(M,D)`) -->

    - <details close>
      <summary>size (<code>DECIMAL(M,D)</code>)</summary>

      - M 最多 65 digits
      - <mark>TODO: 此資料有點問題，待研究</mark> size：`M > D ? M + 2 : D + 2` byte
      - 應該是 M+2 byte，且 D <= M+2 ？
      </details>

    <!-- 範例 -->

    - <details close>
      <summary>範例</summary>

      - EX. `DECIMAL(5,2)`
      - precision 為 5 位數字 (digits)，scale 為 2 位小數 (decimals)
      - 範圍：-999.99 ~ 999.99
      </details>

    <!-- 簡寫 -->

    - <details close>
      <summary>簡寫</summary>

      - `DECIMAL(M)` 等於 `DECIMAL(M,0)`
      - `DECIMAL` 等於 `DECIMAL(10)`

      </details>

    - REF: [MySQL Doc: Precision Math]

    </details>

  <!-- Floating-Point Types (不準確) -->

  - <details close>
    <summary>Floating-Point Types (不準確)</summary>

    - `FLOAT`、`DOUBLE`
    - `FLOAT` 4 byte，`DOUBLE` 8 byte
    - 格式同 `DECIMAL`，但儲存方式不同，精準度也就不同

    </details>

  <!-- Bit-Value Type -->

  - <details close>
    <summary>Bit-Value Type</summary>

    - `BIT`
    - `BIT(M)`: M 可以 1 ~ 64

    <!-- 輸入範例 -->

    - <details close>
      <summary>輸入範例</summary>

      - `INSERT INTO table_name VALUE(b'11111111');`
      - `INSERT INTO table_name VALUE(0b11111111);`
      - `INSERT INTO table_name VALUE(x'FF');`
      - `INSERT INTO table_name VALUE(0xFF);`
      - `INSERT INTO table_name VALUE(255);`
      </details>

    <!-- 輸出範例 -->

    - <details close>
      <summary>輸出範例</summary>

      - `SELECT x, x+0, BIN(x), OCT(x), HEX(x) FROM table_name;`

        ![BIT_present.png](./src/image/BIT_present.png)

      </details>

    </details>

  </details>

<!-- Date Type -->

- <details close>
  <summary>Date Type</summary>

  - REF: [MySQL Doc: Date]

  - `DATE`、`TIME`、`YEAR`、`DATETIME`、`TIMESTAMP`
  - 盡量都按照完整格式書寫。若需使用簡寫，需再仔細研究地雷區
  - 有些可以超出一點 support 的範圍，但不建議也不保證

  <!-- DATE -->

  - <details close>
    <summary><code>DATE</code></summary>

    - `YYYY-MM-DD`
    - `1000-01-01` ~ `9999-12-31`
    - 3 byte

    </details>

  <!-- TIME -->

  - <details close>
    <summary><code>TIME</code></summary>

    - `HH:MM:SS`
    - `-838:59:59` ~ `838:59:59`
    - 3 byte
    - <mark>TODO:Q</mark> 為啥是 838 ？

    </details>

  <!-- YEAR -->

  - <details close>
    <summary><code>YEAR</code></summary>

    - `1901` ~ `2155`
    - 1 byte

    </details>

  <!-- DATETIME -->

  - <details close>
    <summary><code>DATETIME</code></summary>

    - `DATE` + `TIME` + microseconds
    - `YYYY-MM-DD HH:MM:SS`
    - `1000-01-01 00:00:00` ~ `9999-12-31 23:59:59`
    - 8 byte

    </details>

  <!-- TIMESTAMP -->

  - <details close>
    <summary><code>TIMESTAMP</code></summary>

    - `1970-01-01 00:00:01 UTC` ~ `2038-01-19 03:14:07 UTC`
    - 4 byte (INT SIGNED)
    - 時區問題

      - 以當下 SQL server 內設定的時區 (可改設定)，計算出 timestamp
      - version 8.0.22 後，可在 SQL 用 `CAST()` 直接轉

        - EX. `CAST(timestamp AT TIME ZONE INTERVAL '+00:00' AS datetime)`

    - 實用範例

      - 兩種寫法都可以使得每次 update 該 row 時，自動更新 update_at
      - `TIMESTAMP` 有時候會預設直接做此設定

      ```sql
      mysql> CREATE TABLE table_name(
                col_name1 INT,
                update_at TIMESTAMP
                  NOT NULL DEFAULT CURRENT_TIMESTAMP
                  ON UPDATE CURRENT_TIMESTAMP
              );

      mysql> CREATE TABLE table_name(
                col_name1 INT,
                update_at TIMESTAMP
                  NOT NULL DEFAULT NOW()
                  ON UPDATE NOW()
                );
      ```

      ![TIMESTAMP_ON_UPDATE.png](./src/image/TIMESTAMP_ON_UPDATE.png)

    </details>

  <!-- DATETIME vs TIMESTAMP -->

  - <details close>
    <summary><code>DATETIME</code> vs <code>TIMESTAMP</code></summary>

    - Datetime (1000 ～ 9999 年)，Timestamp (1970 ～ 2038 年)
    - For index, Timestamp 比 Datetime 快
    - 面臨的時區問題不同 (詳見注意事項)

    </details>

  </details>

<!-- String Type -->

- <details close>
  <summary>String Type</summary>

  <!-- `Binary strings` vs `Nonbinary strings` -->

  - <details close>
    <summary><code>Binary strings</code> vs <code>Nonbinary strings</code></summary>

    - Binary strings

      - `BINARY`、`VARBINARY`、`BLOB`、

    - Nonbinary strings

      - `CHAR`、`VARCHAR`、`TEXT`

    </details>

  <!-- `CHAR`、`VARCHAR` -->

  - <details close>
    <summary><code>CHAR</code>、<code>VARCHAR</code></summary>

    - 定義要使用幾個 char
    - type：1 byte
    - 英文字母：1 byte

    - `CHAR`

      - 0 ~ 255 char
      - 固定空間

    - `VARCHAR`

      - 0 ~ 65535 char
      - 固定最大可使用空間
      - 改變長度時，會需要重新分配空間

    - function

      - `CHAR_LENGTH()` 計算 char 長度
      - `LENGTH()` 計算 char 所使用空間 (但如果 CHAR(4) 存 'ab'，會回傳 2)

    </details>

  <!-- `BINARY`、`VARBINARY` -->

  - <details close>
    <summary><code>BINARY</code>、<code>VARBINARY</code></summary>

    - 定義要使用幾個 byte
    - `BINARY` 會補滿 0x00，所以用 `LENGTH()` 會回傳固定的

    </details>

  <!-- `BLOB`、`TEXT` -->

  - <details close>
    <summary><code>BLOB</code>、<code>TEXT</code></summary>

    - 儲存空間更大的 `VARBINARY`、`VARCHAR`
    - 2^8, 2^16, 2^24, 2^32 byte
    - 可以設定 `max_sort_length`，排序時，最多只會依照前面 max_sort_length 個去排序

    </details>

  <!-- `ENUM`、`SET` -->

  - <details close>
    <summary><code>ENUM</code>、<code>SET</code></summary>

    <!-- ENUM -->

    - <details close>
      <summary><code>ENUM</code></summary>

      - 實際上是儲存一個 index，可節省空間
      - 也可以在 insert 時，使用 index 編號

        ```sql
        ## EX. S, M, L = 1, 2, 3

        mysql> CREATE TABLE table1(title VARCHAR(5), size ENUM('S', 'M', 'L'));
        mysql> INSERT INTO table1(title, size) VALUE('hat', 1);
        ```

      - <mark>TODO:Q</mark> `ENUM` 在 insert & select 會比 `CHAR` 快？

      </details>

    <!-- SET -->

    - <details close>
      <summary><code>SET</code></summary>

      - 0 ~ 64 member

        ![SET_type_limit.png](./src/image/SET_type_limit.png)

      - 如同 `ENUM`，也是儲存 index

      - 注意每個 member 之間，不能有空格

        ```sql
        ## EX. X
        mysql> INSERT INTO set1 VALUE("enum1, enum2");

        ## EX. O
        mysql> INSERT INTO set1 VALUE("enum1,enum2");
        ```

      - index 換算成二進位，剛好對應到有哪些 member

        - EX. 在 SET("L,M,S") 中，index 與 set 的關係

        | index | L   | M   | S   | set   |
        | ----- | --- | --- | --- | ----- |
        | 0     | 0   | 0   | 0   |       |
        | 1     | 0   | 0   | 1   | S     |
        | 2     | 0   | 1   | 0   | M     |
        | 3     | 0   | 1   | 1   | M,S   |
        | 4     | 1   | 0   | 0   | L     |
        | 5     | 1   | 0   | 1   | L,S   |
        | 6     | 1   | 1   | 0   | L,M   |
        | 7     | 1   | 1   | 1   | L,M,S |

      - <mark>TODO:</mark> EXPLAIN 一下使用 index 跟 明文時，是否有效率差異

      </details>

    </details>

  </details>

## # 底層研究

<!-- B+ Tree -->

- <details close>
  <summary>B+ Tree</summary>

  - 因為資料庫存在 disk，選擇的重點在減少 I/O

    - 減少階數，減少 I/O
    - 盡量將每個 node 大小調整在 disk 的一個 block (EX. 4KB, 16KB..etc)，以減少 I/O
    - 盡量整理整齊，能放在同一個 block 以減少 I/O

  - 按順序連結，使順序遍歷更快

  - REF

    - [資料庫層的核心 - 索引結構演化論 B+樹]
    - [平衡二叉樹、B 樹、B+樹、B*樹理解其中一種你就都明白了]
    - [MySQL 底層為什麼要選用 B+樹作為索引的數據結構呢？]

  </details>

<!-- Index -->

- <details close>
  <summary>Index</summary>

  <!-- Clustered Index -->

  - <details close>
    <summary>Clustered Index</summary>

    - 一個 table 只能有一個 Clustered Index，所以應該慎選要給哪個 key 用，以發揮最大效能利益
    - key 選擇要點：不會改、常查詢、容量小、插入順序為遞增、重複率低

    - REF

      - [聚簇索引]
      - [詳解聚簇索引]
      - [MySQL 面試：談談你對聚簇索引的理解]

    </details>

  <!-- Covering Index -->

  - <details close>
    <summary>Covering Index</summary>

    - 前提要是 Clustered Index
    - 讓 index 中包含一些資料，使得查詢時可以直接從 index 取得資料
    - REF

      - [MySQL 覆蓋索引詳解]

    </details>

  <!-- Filter Index -->

  - <details close>
    <summary>Filter Index</summary>

    - 特化的 Covering Index，可以設定在 index 中存入的 Col，只符合特定條件的 value 才存入（並非所有的 Row 都存）
    - REF

      - [資料庫索引深入淺出(二)]

    </details>

  <!-- ICP (Index Condition Pushdown) -->

  - <details close>
    <summary>ICP (Index Condition Pushdown)</summary>

    - 索引條件下推（Index Condition Pushdown，ICP）
    - 過濾的動作由下層的存儲引擎層通過使用索引來完成，而不需要上推到 Server 層進行處理
    - 預設開啟

    </details>

  <!-- 其他 -->

  - <details close>
    <summary>其他</summary>

    - 需了解優化器自動選擇 index 的規則，自動選擇的並非一定就是最高效的，而是選擇 Cost Base Optimizer 最小的
    - 有時需把多餘的 index 刪除，才能讓其選中更高效的那一個 index
    - 優化器會將 possible_keys 都試一遍，因此一個查詢若有太多 possible_keys，也會變慢
    - 若在條件式中對 key 做運算，則會讓 index 失效。雖然新增了「函數索引」，但也是多建立一個 index

    </details>

  - REF: [圖解｜索引覆蓋、索引下推以及如何避免索引失效]

  </details>

## # 效能研究

- REF: [MySQL EXPLAIN Extra 解析]

<!-- 使用 sql function 查詢，對 index 的影響 ( EX. CONCAT ) -->

- <details close>
  <summary>使用 sql function 查詢，對 index 的影響 ( EX. CONCAT )</summary>

  - 用 `SELECT CONCAT(a, b)`，不影響是否使用 index
  - 用 `WHERE CONCAT(a, b)=""`，則無法直接使用 index 快速查詢
  - 也可以另外建一個 `CONCAT(a, b)` 的 index

  ![Index_vs_CONCAT.png](./src/image/Index_vs_CONCAT.png)

  - 數據解析：
    - type index 會進行 whole index 掃描
    - type ref 直接二分法搜尋該 index

  </details>

<!-- 使用 `ORDER BY` 查詢，是否選擇 index -->

- <details close><summary>使用 <code>ORDER BY</code> 查詢，是否選擇 index</summary>

  - REF: [MySQL DOC: ORDER BY Optimization]

  - 如果需要再去查全表，則不會使用 index，而是重新對資料做排序

  ![Index_VS_OrderBy1.png](./src/image/Index_VS_OrderBy1.png)

  - 若加上 WHERE 只取得某個區間，會依照區間大小選用 index。區間需要多小？

  ![Index_VS_OrderBy2.png](./src/image/Index_VS_OrderBy2.png)

  </details>

<!-- GROUP BY 與 index -->

- <details close>
  <summary><code>GROUP BY</code> 與 index</summary>

  - 沒有 index，會 `Using temporary`，創建一個臨時表

    ![Index_VS_GroupBy1.png](./src/image/Index_VS_GroupBy1.png)

  - 有 index，會 `Using index`，使用 covering index

    ![Index_VS_GroupBy2.png](./src/image/Index_VS_GroupBy2.png)

  </details>

<!-- COUNT(*) -->

- <details close>
  <summary><code>COUNT(*)</code></summary>

  - InnoDB 需要每次重新算，會掃描全表(or index)

  <!-- COUNT(col) -->

  - `COUNT(col)` 用來全掃描的表(or index)，COUNT() 的 col 是否包含 NULL，會影響是否每次都需做判斷，影響效能

  <!-- 簡介 COUNT() -->

  - <details close>
    <summary>簡介 COUNT()</summary>

    - `COUNT(*)`：所有 row，不論是不是 NULL
    - `COUNT(col)`：只計算該 col 不是 NULL 的 row 數量

    </details>

  <!-- MyISAM VS InnoDB -->

  - <details close>
    <summary>MyISAM VS InnoDB</summary>

    - MyISAM 有記錄 count 結果，InnoDB 需要每次重新算
    - 最大原因是： MyISAM 不支持 Transaction， InnoDB 支持 Transaction

      - 因此 InnoDB 若記錄 count 結果，沒意義。因為在不同 Transaction 中可能會改變，不精準。
      - 即便每次重新算，也只是得到在該計算次中的數量
      - MySQL InnoDB 可使用 `SHOW TABLE STATUS` 直接取得估算

    </details>

  <!-- InnoDB 解決方案 -->

  - <details close>
    <summary>InnoDB 解決方案</summary>

    - 可另開 table 存 conut，依照需求分兩種做法

      - `OLTP` (Online Transactional Processing)

        - 注重一致性，所以安排把 update count 包含在每次 Transaction 中

      - `OLAP` (Online Analytical Processing)

        - 只需用來分析，因此可以設定一個時間 update count 一次

    </details>

  - REF: [分析 COUNT(*)] | [MySQL doc: COUNT()]

  </details>

<!-- MAX, MIN 與 index -->

- <details close>
  <summary><code>MAX</code>, <code>MIN</code> 與 index</summary>

  - 沒有 index，會掃全表

    ![Index_VS_MAX1.png](./src/image/Index_VS_MAX1.png)

  - 有 index

    - `Select tables optimized away`，可以直接 O(1) 回傳
    - 因為 B+ Tree 會串成 linked list，還有 head & tail
    - REF: [MySQL issue answer]

    ![Index_VS_MAX2.png](./src/image/Index_VS_MAX2.png)

  </details>

<!-- IN vs OR -->

- <details close>
  <summary><code>IN</code> vs <code>OR</code></summary>

  - `IN` & `OR` 在效能上看起來是一樣的，只差別在閱讀性

    ![IN_vs_OR.png](./src/image/IN_vs_OR.png)

    - 其中 `rows` 解讀：4 個條件 ＋ 5 筆資料 － 2 種重複

  </details>

## # 問題集中區

<!-- Composite Primary Keys -->

- <details close>
  <summary>Composite Primary Keys</summary>

  <!-- AUTO_INCREMENT VS Composite Primary Keys -->

  - <details close>
    <summary>在使用 <code>AUTO_INCREMENT</code> 情況下，再設置 <b>Composite Primary Keys</b> 似乎沒有意義？</summary>

    - 是，因為 `AUTO_INCREMENT` 的 column 的每筆資料一定會不同

    </details>

  <!-- 電商限購商品 VS Composite Primary Keys -->

  - <details close>
    <summary>電商希望客戶只能購買一件同商品時，會用 <b>Composite Primary Keys</b> 來達成嗎？</summary>

    - 多：通常會在後端處理，因為這類型活動很難在一開始就設定好 DB

    </details>

  </details>

<!-- 生產環境 VS DELETE  -->

- <details close>
  <summary>生產環境，有什麼情況還是會用<code>DELETE</code>嗎？</summary>

  - 可能有些資料沒必要被救回，且資料庫資源有限，就會直接用 `DELETE`

  </details>

<!-- Table 應該都用複數？ -->

- <details close>
  <summary>Table 應該都用複數？</summary>

  - 是，MongoDB 還會自動幫你改成複數

  </details>

<!-- 中途更改某 col 的 Data type 有哪些問題？有哪些限制？DB 會做哪些動作？ -->

- <details close>
  <summary><mark>TODO:Q</mark> 中途更改某 col 的 Data type 有哪些問題？有哪些限制？DB 會做哪些動作？</summary>

  - 更改方式：`ALTER TABLE table_name CHANGE old_col_name new_col_name new_type;`

  </details>

<!-- COLLATE 是在哪個步驟上起作用？ -->

- <details close>
  <summary><mark>TODO:Q</mark> COLLATE 是在哪個步驟上起作用？</summary>

  </details>

<!-- Nonbinary strings 跟 binary strings 在儲存上，本質上有什麼差異？ -->

- <details close>
  <summary><mark>TODO:Q</mark> Nonbinary strings 跟 binary strings 在儲存上，本質上有什麼差異？</summary>

  - binary strings 是否只能輸入 ASCII 的內容？如果輸入中文，是否會自動轉成數個 byte？

  </details>

<!-- CHARACTER SET & COLLATE 一般會習慣設定整個 Database, Table, 還是針對個別 column 做設定？ -->

- <details close>
  <summary><mark>TODO:Q</mark>CHARACTER SET & COLLATE 一般會習慣設定整個 Database, Table, 還是針對個別 column 做設定？</summary>

  </details>

---

## # 其他補充

<!-- 注意事項 -->

- 注意事項：

  <!-- `AUTO_INCREMENT` & `PRIMARY KEY` & `UNIQUE` -->

  - <details close>
    <summary><code>AUTO_INCREMENT</code> & <code>PRIMARY KEY</code> & <code>UNIQUE</code></summary>

    - 只能有一個 column 設置 `AUTO_INCREMENT`，並且一定要設置為 KEY (PRIMARY 或 UNIQUE)
    - 若沒有其他 column 被設置為 PK，則此 column 就會直接成為 PK
    - 可以使用 `PRIMARY KEY(col1, col2)`，跟其他 column 一起成為 Composite Primary Keys
    - 即便使用 `UNIQUE`，也允許多筆資料都是 NULL

    </details>

  <!-- 大小寫敏感問題 -->

  - <details close>
    <summary>大小寫敏感問題</summary>

    - 環境不同，可能導致對大小寫敏感，有不同的結果

    </details>

  <!-- ORDER BY 的 Collation 的選擇 -->

  - <details close>
    <summary>ORDER BY 的 Collation 的選擇</summary>

    - 不同環境可能有不同的預設設定，需統一設定
    - [MySQL DOC: Character Sets, Collations, Unicode]

    </details>

  <!-- 一些淺規則可以透過 Server SQL Modes 調整 -->

  - <details close>
    <summary>一些淺規則可以透過 Server SQL Modes 調整</summary>

    - [MySQL Doc: Server SQL Modes]

    </details>

  <!-- TIMESTAMP vs DATETIME - 時區問題 -->

  - <details close>
    <summary><code>TIMESTAMP</code> vs <code>DATETIME</code> - 時區問題</summary>

    - REF: [MySQL Doc: Date]

    - <details close>
      <summary>DATETIME 在儲存時，並不會儲存時區資訊，但是會以 DB server 所設定的時區所得到的時間來儲存</summary>

      - 儲存時很容易出錯

      </details>

    - <details close>
      <summary>TIMESTAMP 在呈現時，會自動轉換成 DB server 所設定的時區</summary>

      <!-- 舊版解法： -->

      - <details close>
        <summary>舊版解法：</summary>

        - 需查看 DB server 所設定的時區，也可自己設定

          - `SET time_zone = "+08:00";`
          - `SET time_zone = 'Asia/Taipei';`

        - 每次都要檢查或設定很麻煩
        - 為了呈現改設定，可能會影響到其他地方

        </details>

      <!-- version 8.0.22 解法： -->

      - <details close>
        <summary>version 8.0.22 解法：</summary>

        - `CAST(timestamp AT TIME ZONE INTERVAL "+00:00" AS datetime)`
        - 直接寫在 SQL，不用管不同 server 不同設定
        </details>

      </details>

    </details>

<!-- 小技巧 -->

- 小技巧：

  <!-- UPDATE 技巧 -->

  - <details close>
    <summary><code>UPDATE</code>技巧</summary>

    - 可以先 `SELECT` 查看 `WHERE` 的條件是否符合需求，再將其改為 `UPDATE`

    </details>

  <!-- 查看一些優化的條件設定 -->

  - <details close>
    <summary><code>SHOW VARIABLES LIKE 'optimizer_switch';</code></summary>

    - 查看一下當前一些優化的條件設定，如： ICP 的狀態

    </details>

  <!-- OPTIMIZE TABLE -->

  - <details close>
    <summary><code>OPTIMIZE TABLE</code></summary>

    - [Optimize Table 整理 MySQL 表空間]
    - 可安排在離峰時段進行 OPTIMIZE TABLE，以整理 table，使減少查詢時 I/O 次數

    </details>

<!-- 小工具 -->

- 小工具：

  <!-- 學習工具 -->

  - <details close>
    <summary>學習工具</summary>

    </details>

  <!-- 開發工具 -->

  - <details close>
    <summary>開發工具</summary>

    - [MySQL shell]

      - shell 中自動補全跟提示

    </details>

<!-- 補充學習 -->

- 補充學習：

  <!-- 文件 -->

  - <details close>
    <summary>文件</summary>

    </details>

  <!-- 範例研究 -->

  - <details close>
    <summary>範例研究</summary>

    </details>

---

## # 踩雷實錄

---

## # 延伸討論

<!-- Database in Docker? -->

- <details close>
  <summary>Database in Docker?</summary>

  - [Should You Run Your Database in Docker?]

  </details>

<!-- MySQL 開發規範研究 -->

- <details close>
  <summary>MySQL 開發規範研究</summary>

  - [MySQL 開發規範參考]

  </details>

<!-- Stored Procedure -->

- <details close>
  <summary>Stored Procedure</summary>

  - 在資料庫 server 上保存的預編譯的程式，像是開客製化的 API，讓外部可以串接使用

  </details>

<!-- Filesort 屬於 Unstable Sort？ -->

- <details close>
  <summary>Filesort 屬於 Unstable Sort？</summary>

  - [MySQL：排序（filesort）詳細解析]
  - [What is the sorting algorithm behind ORDER BY query in MySQL?]
  - GPT：早期為 Quicksort，5.0 改為 Batched Key Access Filesort，此兩種皆為 unstable

  ![GPT_MySQL_filesort.png](./src/image/GPT_MySQL_filesort.png)

  </details>

<!-- 「使用 SQL Function」 VS 「在 server 處理」 -->

- <details close>
  <summary>「使用 SQL Function」 VS 「在 server 處理」</summary>

  - 網路傳輸量？
  - 資料庫記憶體消耗？
  - 可能有些系統並不需要多建立一個 server？

  </details>

<!-- WHER 中使用 "!=" 可否使用 index -->

- <details close>
  <summary>WHER 中使用 "!=" 可否使用 index</summary>

  - 舊版不行，新版可以
  - REF: [MySQL 中 IS NULL、IS NOT NULL、!= 不能用索引？]

  </details>

<!-- Data Proxy -->

- <details close>
  <summary>Data Proxy</summary>

  - [Prisma Doc: Data Proxy]

  </details>

---

# XX

- <details close>
  <summary></summary>

  </details>
